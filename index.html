<!doctype html>
<html lang="ko">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>ZOMBIE CITY1</title>

<style>
body{
  margin:0;
  background:#ffffff;
  font-family: Arial, Helvetica, sans-serif;
}

.wrap{
  width:100%;
  text-align:center;
}

/* 제목 */
.title{
  font-size:22px;
  font-weight:700;
  margin:20px 0 12px;
}

/* 카드 */
.card{
  width:1024px;
  height:768px;
  max-width:92vw;
  margin:0 auto;
  border:2px solid #111;
  position:relative;
  overflow:hidden;
  background:#fff;
}

/* 레이어 */
.layer{
  position:absolute;
  inset:0;
  display:flex;
  align-items:center;
  justify-content:center;
}

#cityImg{
  height:100%;
  width:auto;
  position:absolute;
  left:50%;
  transform:translateX(-50%);
  user-select:none;
  -webkit-user-drag:none;
  pointer-events:none;
}

#zombieImg,#puzzleImg{
  width:100%;
  height:100%;
  object-fit:contain;
  display:none;
  user-select:none;
  -webkit-user-drag:none;
  pointer-events:none;
}

/* UI */
.ui{
  width:1024px;
  max-width:92vw;
  margin:12px auto 0;
}

.timer{
  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
  font-size:48px;
  display:none;
  letter-spacing:2px;
}

.answerRow{
  display:none;
  margin-top:8px;
}

input{
  border:2px solid #111;
  padding:12px;
  font-size:18px;
  width:260px;
  text-align:center;
  box-sizing:border-box;
}

.controls{
  width:1024px;
  max-width:92vw;
  margin:16px auto;
  display:grid;
  grid-template-columns:1fr 1fr;
  gap:10px;
}

button{
  border:2px solid #111;
  background:#fff;
  padding:12px;
  font-size:16px;
  cursor:pointer;
  box-sizing:border-box;
}
button:active{ transform: translateY(1px); }
</style>
</head>

<body>
<div class="wrap">

  <div class="title">ZOMBIE CITY1</div>

  <div class="card">
    <!-- city -->
    <div class="layer"><img id="cityImg" src=""></div>
    <!-- zombie overlay -->
    <div class="layer"><img id="zombieImg" src=""></div>
    <!-- puzzle overlay -->
    <div class="layer"><img id="puzzleImg" src=""></div>
  </div>

  <div class="ui">
    <div id="timer" class="timer">15</div>
    <div id="answerRow" class="answerRow">
      <input id="answerInput" placeholder="ANSWER" autocomplete="off" spellcheck="false">
      <div>ENTER 누르기</div>
    </div>
  </div>

  <div class="controls">
    <button onclick="location.reload()">다시 시작</button>
    <button onclick="location.href='index.html'">메뉴</button>
  </div>

</div>

<script>
/*********************************************************
 * ✅ 파일 목록
 *********************************************************/
const cityImages = Array.from({length:5},(_,i)=>`static/city${i+1}.png`);
const zombieImages = Array.from({length:5},(_,i)=>`static/zombie${i+1}.png`);

/*********************************************************
 * ✅ 퍼즐(1-n 구조): 여기만 추가/수정하면 됨
 *********************************************************/
const puzzles = [
  { img:"static/puzzle1-1.png", answer:"SOS" },
  { img:"static/puzzle1-2.png", answer:"CAP" },
  { img:"static/puzzle1-3.png", answer:"0835" }  // ← 예시(원하면 바꾸세요)
];

/*********************************************************
 * ✅ 요소
 *********************************************************/
const cityImg = document.getElementById("cityImg");
const zombieImg = document.getElementById("zombieImg");
const puzzleImg = document.getElementById("puzzleImg");
const timerEl = document.getElementById("timer");
const answerRow = document.getElementById("answerRow");
const answerInput = document.getElementById("answerInput");

/*********************************************************
 * ✅ 상태
 *********************************************************/
let puzzleIndex = 0;
let cityMove = true;
let rafId = null;
let countdownId = null;
let zombieTimeoutId = null;
let overlayTimeoutId = null;
let phase = "CITY"; // CITY | ZOMBIE | PUZZLE | RESULT

/*********************************************************
 * ✅ 유틸
 *********************************************************/
const rand = arr => arr[Math.floor(Math.random()*arr.length)];

function resetUI(){
  zombieImg.style.display = "none";
  puzzleImg.style.display = "none";
  timerEl.style.display = "none";
  answerRow.style.display = "none";
  answerInput.value = "";
}

function stopAllTimers(){
  if(rafId) cancelAnimationFrame(rafId);
  rafId = null;

  if(countdownId) clearInterval(countdownId);
  countdownId = null;

  if(zombieTimeoutId) clearTimeout(zombieTimeoutId);
  zombieTimeoutId = null;

  if(overlayTimeoutId) clearTimeout(overlayTimeoutId);
  overlayTimeoutId = null;
}

function setTimerDisplay(sec){
  timerEl.textContent = String(sec).padStart(2,"0");
}

/*********************************************************
 * ✅ 여러 기기 동시 실행 시, "좀비 등장 겹침 방지" 스케줄
 * - 서버 없이 가능
 * - 절대시간(Date.now()) 기반
 * - 페이지별 슬롯 분할
 *********************************************************/
const CYCLE_MS = 80000;
const SLOT_MS  = 15000;
const GUARD_MS = 5000;

/* page1 = 1 */
const PAGE_ID = 1;
const SLOT_START_MS = (PAGE_ID - 1) * (SLOT_MS + GUARD_MS); // page1=0ms

function seededRandom01(cycleIndex, pageId){
  // 결정적 난수(기기/브라우저가 달라도 동일)
  let x = (cycleIndex + 1) * 1103515245 + pageId * 12345;
  x = (x ^ (x >>> 16)) >>> 0;
  return (x % 100000) / 100000;
}

function scheduleZombieNoOverlap(){
  // 이미 퍼즐/결과 중이면 스케줄 안 잡음
  if(phase !== "CITY") return;

  const now = Date.now();
  const cycleIndex = Math.floor(now / CYCLE_MS);
  const inCycle = now % CYCLE_MS;

  // 이 사이클에서 page1 슬롯 안 목표시점(결정적 랜덤)
  const r = seededRandom01(cycleIndex, PAGE_ID);
  const targetInCycle =
    SLOT_START_MS + GUARD_MS + r * (SLOT_MS - GUARD_MS * 2);

  let wait = targetInCycle - inCycle;
  if(wait < 0) wait += CYCLE_MS;

  zombieTimeoutId = setTimeout(() => {
    // 여전히 CITY면 좀비 등장
    if(phase === "CITY") showZombie();
  }, wait);
}

/*********************************************************
 * ✅ CITY 시작/재시작
 * - 매번 city1~5 랜덤 선택
 * - 움직임 시작
 * - 좀비 등장 스케줄(겹침 방지 방식)
 *********************************************************/
function startCity(){
  stopAllTimers();
  resetUI();

  phase = "CITY";
  cityMove = true;

  cityImg.src = rand(cityImages);

  const t0 = performance.now();
  function tick(t){
    if(!cityMove || phase !== "CITY") return;
    const x = Math.sin((t - t0)/1000 * 0.6) * 30; // 천천히
    cityImg.style.transform = `translateX(calc(-50% + ${x}px)) scale(1.1)`;
    rafId = requestAnimationFrame(tick);
  }
  rafId = requestAnimationFrame(tick);

  scheduleZombieNoOverlap();
}

/*********************************************************
 * ✅ ZOMBIE 등장
 * - zombie는 city 위에 오버레이로 랜덤
 * - zombie 등장 시 city는 고정(움직임 중지)
 * - 2초 후 puzzle 오버레이
 *********************************************************/
function showZombie(){
  if(phase !== "CITY") return;

  phase = "ZOMBIE";
  cityMove = false;
  if(rafId) cancelAnimationFrame(rafId);
  rafId = null;

  // city는 현재 프레임 위치에서 고정됨(변형 유지)
  zombieImg.src = rand(zombieImages);
  zombieImg.style.display = "block";

  overlayTimeoutId = setTimeout(() => {
    startPuzzle();
  }, 2000);
}

/*********************************************************
 * ✅ PUZZLE
 * - puzzle은 zombie 위에 순서대로
 * - 15초 카운트다운
 *********************************************************/
function startPuzzle(){
  if(phase !== "ZOMBIE") return;

  // 퍼즐이 다 끝나면 다시 0부터(원하면 종료로 바꿀 수 있음)
  if(puzzleIndex >= puzzles.length) puzzleIndex = 0;

  phase = "PUZZLE";
  const p = puzzles[puzzleIndex];

  puzzleImg.src = p.img;
  puzzleImg.style.display = "block";

  timerEl.style.display = "block";
  answerRow.style.display = "block";
  answerInput.value = "";
  answerInput.focus();

  let left = 20;
  setTimerDisplay(left);

  countdownId = setInterval(() => {
    left -= 1;
    setTimerDisplay(Math.max(0,left));
    if(left <= 0){
      clearInterval(countdownId);
      countdownId = null;
      fail();
    }
  }, 1000);
}

/*********************************************************
 * ✅ 결과 처리
 * - success/fail 표시 후 3초 뒤 city로 복귀(랜덤 city)
 *********************************************************/
function success(){
  if(phase !== "PUZZLE") return;

  phase = "RESULT";
  if(countdownId) clearInterval(countdownId);
  countdownId = null;

  timerEl.style.display = "none";
  answerRow.style.display = "none";

  puzzleImg.src = "static/success.png";

  puzzleIndex += 1;

  overlayTimeoutId = setTimeout(() => {
    startCity();
  }, 3000);
}

function fail(){
  if(phase !== "PUZZLE") return;

  phase = "RESULT";
  if(countdownId) clearInterval(countdownId);
  countdownId = null;

  timerEl.style.display = "none";
  answerRow.style.display = "none";

  puzzleImg.src = "static/fail.png";

  puzzleIndex += 1;

  overlayTimeoutId = setTimeout(() => {
    startCity();
  }, 3000);
}

/*********************************************************
 * ✅ 입력 처리 (대문자 강제 + Enter 제출)
 *********************************************************/
answerInput.addEventListener("input", () => {
  answerInput.value = (answerInput.value || "").toUpperCase();
});

answerInput.addEventListener("keydown", (e) => {
  if(e.key === "Enter"){
    e.preventDefault();
    if(phase !== "PUZZLE") return;

    const p = puzzles[puzzleIndex] || null;
    const user = (answerInput.value || "").trim().toUpperCase();

    // 빈 입력도 오답 처리
    if(!p || user !== p.answer){
      fail();
    } else {
      success();
    }
  }
});

/*********************************************************
 * ✅ 시작
 *********************************************************/
startCity();
</script>
</body>
</html>
